// native-lib.cpp
//
// Hardened, compile-time-configured JNI gate for secrets.
// - Values are baked by CMake into security_config.h (package + signer allowlist).
// - Signer allowlist should include BOTH release & debug cert SHA-256 fingerprints
//   (lowercase hex, no colons) so the same .so works for both builds.
// - Gate logic: (package == bakedPackage) && (runtimeSigner ∈ bakedAllowlist)
//
// NOTE: If your Kotlin class/package differs, adjust the JNI method names accordingly.

#include <jni.h>
#include <string>
#include <vector>
#include <android/log.h>
#include "security_config.h"   // generated by CMake from security_config.h.in

#define LOG_TAG "NativeLib"
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,  LOG_TAG, __VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN,  LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)

// ---------- Small JNI helpers ----------
static bool ClearIfException(JNIEnv* env) {
    if (env->ExceptionCheck()) { env->ExceptionDescribe(); env->ExceptionClear(); return true; }
    return false;
}

static jobject CurrentApplication(JNIEnv* env) {
    // ActivityThread.currentApplication() → Application
    jclass at = env->FindClass("android/app/ActivityThread");
    if (!at || ClearIfException(env)) return nullptr;
    jmethodID mid = env->GetStaticMethodID(at, "currentApplication", "()Landroid/app/Application;");
    if (!mid || ClearIfException(env)) return nullptr;
    jobject app = env->CallStaticObjectMethod(at, mid);
    if (ClearIfException(env)) return nullptr;
    return app; // local ref (ok within this native frame)
}

static std::string JStringToUtf8(JNIEnv* env, jstring s) {
    if (!s) return {};
    const char* p = env->GetStringUTFChars(s, nullptr);
    if (!p) return {};
    std::string out(p);
    env->ReleaseStringUTFChars(s, p);
    return out;
}

static jbyteArray NewBA(JNIEnv* env, const std::vector<uint8_t>& v) {
    jbyteArray a = env->NewByteArray((jsize)v.size());
    if (!a) return nullptr;
    if (!v.empty()) env->SetByteArrayRegion(a, 0, (jsize)v.size(), reinterpret_cast<const jbyte*>(v.data()));
    return a;
}

static std::string BytesToHexLower(const std::vector<uint8_t>& v) {
    static const char* H = "0123456789abcdef";
    std::string out; out.resize(v.size() * 2);
    for (size_t i = 0; i < v.size(); ++i) {
        out[2*i+0] = H[(v[i] >> 4) & 0xF];
        out[2*i+1] = H[(v[i]     ) & 0xF];
    }
    return out;
}

// ---------- Gate #1: package must match ----------
static bool PackageOk(JNIEnv* env) {
    jobject app = CurrentApplication(env);
    if (!app) return false;

    jclass ctx = env->GetObjectClass(app);
    if (!ctx || ClearIfException(env)) return false;

    jmethodID midGetPkg = env->GetMethodID(ctx, "getPackageName", "()Ljava/lang/String;");
    if (!midGetPkg || ClearIfException(env)) return false;

    jstring jpkg = (jstring)env->CallObjectMethod(app, midGetPkg);
    if (ClearIfException(env) || !jpkg) return false;

    const std::string pkg = JStringToUtf8(env, jpkg);
    LOGI("Detected package: %s | expected: %s", pkg.c_str(), BAKED_EXPECTED_PKG);
    return pkg == std::string(BAKED_EXPECTED_PKG);
}

// ---------- Read runtime signer certificate bytes (first signer) ----------
static std::vector<uint8_t> GetFirstSignerBytes(JNIEnv* env) {
    std::vector<uint8_t> out;

    jobject app = CurrentApplication(env);
    if (!app) return out;

    jclass ctx = env->GetObjectClass(app);
    if (!ctx || ClearIfException(env)) return out;

    // pm + pkg
    jmethodID midPM  = env->GetMethodID(ctx, "getPackageManager", "()Landroid/content/pm/PackageManager;");
    jmethodID midPkg = env->GetMethodID(ctx, "getPackageName", "()Ljava/lang/String;");
    if (!midPM || !midPkg || ClearIfException(env)) return out;

    jobject pm  = env->CallObjectMethod(app, midPM);
    jstring pkg = (jstring)env->CallObjectMethod(app, midPkg);
    if (ClearIfException(env) || !pm || !pkg) return out;

    // SDK level
    jclass ver = env->FindClass("android/os/Build$VERSION");
    if (!ver || ClearIfException(env)) return out;
    jfieldID fSdk = env->GetStaticFieldID(ver, "SDK_INT", "I");
    if (!fSdk || ClearIfException(env)) return out;
    jint sdk = env->GetStaticIntField(ver, fSdk);

    // pm.getPackageInfo(pkg, flags)
    jclass pmCls = env->GetObjectClass(pm);
    if (!pmCls || ClearIfException(env)) return out;

    jmethodID midPI = env->GetMethodID(pmCls, "getPackageInfo",
            "(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;");
    if (!midPI || ClearIfException(env)) return out;

    const jint GET_SIGNATURES            = 0x00000040;   // pre-P
    const jint GET_SIGNING_CERTIFICATES  = 0x08000000;   // P+
    const jint flags = (sdk >= 28) ? GET_SIGNING_CERTIFICATES : GET_SIGNATURES;

    jobject pi = env->CallObjectMethod(pm, midPI, pkg, flags);
    if (!pi || ClearIfException(env)) return out;

    if (sdk >= 28) {
        // PackageInfo.signingInfo.apkContentsSigners[0].toByteArray()
        jclass piCls = env->GetObjectClass(pi);
        jfieldID fSI = env->GetFieldID(piCls, "signingInfo", "Landroid/content/pm/SigningInfo;");
        if (!fSI || ClearIfException(env)) return out;

        jobject si = env->GetObjectField(pi, fSI);
        if (!si || ClearIfException(env)) return out;

        jclass siCls = env->GetObjectClass(si);
        jmethodID midSigners = env->GetMethodID(siCls, "getApkContentsSigners", "()[Landroid/content/pm/Signature;");
        if (!midSigners || ClearIfException(env)) return out;

        jobjectArray arr = (jobjectArray)env->CallObjectMethod(si, midSigners);
        if (ClearIfException(env) || !arr || env->GetArrayLength(arr) <= 0) return out;

        jobject sig0 = env->GetObjectArrayElement(arr, 0);
        if (!sig0 || ClearIfException(env)) return out;

        jclass sigCls = env->GetObjectClass(sig0);
        jmethodID midToBytes = env->GetMethodID(sigCls, "toByteArray", "()[B");
        if (!midToBytes || ClearIfException(env)) return out;

        jbyteArray blob = (jbyteArray)env->CallObjectMethod(sig0, midToBytes);
        if (ClearIfException(env) || !blob) return out;

        jsize n = env->GetArrayLength(blob);
        out.resize(n);
        if (n > 0) env->GetByteArrayRegion(blob, 0, n, reinterpret_cast<jbyte*>(out.data()));
        return out;
    } else {
        // PackageInfo.signatures[0].toByteArray()
        jclass piCls = env->GetObjectClass(pi);
        jfieldID fSigs = env->GetFieldID(piCls, "signatures", "[Landroid/content/pm/Signature;");
        if (!fSigs || ClearIfException(env)) return out;

        jobjectArray arr = (jobjectArray)env->GetObjectField(pi, fSigs);
        if (ClearIfException(env) || !arr || env->GetArrayLength(arr) <= 0) return out;

        jobject sig0 = env->GetObjectArrayElement(arr, 0);
        if (!sig0 || ClearIfException(env)) return out;

        jclass sigCls = env->GetObjectClass(sig0);
        jmethodID midToBytes = env->GetMethodID(sigCls, "toByteArray", "()[B");
        if (!midToBytes || ClearIfException(env)) return out;

        jbyteArray blob = (jbyteArray)env->CallObjectMethod(sig0, midToBytes);
        if (ClearIfException(env) || !blob) return out;

        jsize n = env->GetArrayLength(blob);
        out.resize(n);
        if (n > 0) env->GetByteArrayRegion(blob, 0, n, reinterpret_cast<jbyte*>(out.data()));
        return out;
    }
}

// ---------- Compute SHA-256 (lowercase hex) using java.security.MessageDigest ----------
static std::string Sha256Lower(JNIEnv* env, const std::vector<uint8_t>& data) {
    if (data.empty()) return {};
    jclass mdCls = env->FindClass("java/security/MessageDigest");
    if (!mdCls || ClearIfException(env)) return {};
    jmethodID midGet = env->GetStaticMethodID(mdCls, "getInstance",
            "(Ljava/lang/String;)Ljava/security/MessageDigest;");
    if (!midGet || ClearIfException(env)) return {};
    jstring algo = env->NewStringUTF("SHA-256");
    if (!algo) return {};
    jobject md = env->CallStaticObjectMethod(mdCls, midGet, algo);
    if (ClearIfException(env) || !md) return {};
    jclass mdInst = env->GetObjectClass(md);
    jmethodID midDigest = env->GetMethodID(mdInst, "digest", "([B)[B");
    if (!midDigest || ClearIfException(env)) return {};

    jbyteArray in = NewBA(env, data);
    if (!in) return {};
    jbyteArray out = (jbyteArray)env->CallObjectMethod(md, midDigest, in);
    if (ClearIfException(env) || !out) return {};

    jsize n = env->GetArrayLength(out);
    std::vector<uint8_t> digest((size_t)std::max<jsize>(0, n));
    if (n > 0) env->GetByteArrayRegion(out, 0, n, reinterpret_cast<jbyte*>(digest.data()));
    return BytesToHexLower(digest);  // lowercase hex, no colons
}

// ---------- Gate #2: signer must be in baked allowlist (release OR debug) ----------
static bool SignerOk(JNIEnv* env) {
    const std::vector<uint8_t> cert = GetFirstSignerBytes(env);
    if (cert.empty()) { LOGW("No signer bytes"); return false; }
    const std::string shaLower = Sha256Lower(env, cert);
    if (shaLower.empty()) { LOGW("SHA-256 failed"); return false; }

    for (int i = 0; i < BAKED_ALLOWED_CERTS_COUNT; ++i) {
        if (shaLower == std::string(BAKED_ALLOWED_CERTS[i])) return true;
    }
    LOGE("Signer %s not in allowlist", shaLower.c_str());
    return false;
}

// ---------- Final gate ----------
static bool ChecksPass(JNIEnv* env) {
    // Require BOTH: correct package AND signer present in baked allowlist.
    return PackageOk(env) && SignerOk(env);
}

// ================= JNI exports (Kotlin object: com.corexero.nativelib.NativeLib) =================

// Secret #1 (SQLCipher key, for example) — only returned if checks pass.
extern "C" JNIEXPORT jstring JNICALL
Java_com_corexero_nativelib_NativeLib_getDBEncryptKey(JNIEnv* env, jclass) {
    if (!ChecksPass(env)) return env->NewStringUTF("");
    const std::string key = "#Corexero@28@virat@abhi@rahul";
    return env->NewStringUTF(key.c_str());
}

// Secret #2 (Review API key) — only returned if checks pass.
extern "C" JNIEXPORT jstring JNICALL
Java_com_corexero_nativelib_NativeLib_getReviewApiKey(JNIEnv* env, jclass) {
    if (!ChecksPass(env)) return env->NewStringUTF("");
    const std::string key =
            "LpynjL15U6RZjfSfTxXm4ygHOv7XPna8J5ApVRAXABESeJ9fJh0JEsLGRgfU0ynLZUdqXhXsJE9hgZqkbMTYn8ThaDk9ihUVWWWIIdg2m8uHfh0FHir8zewVE9lOCEA3";
    return env->NewStringUTF(key.c_str());
}

// Expose the baked allowlist back to Kotlin (for diagnostics / external checks).
extern "C" JNIEXPORT jobjectArray JNICALL
Java_com_corexero_nativelib_NativeLib_getSignerSha256(JNIEnv* env, jclass) {
    jclass strCls = env->FindClass("java/lang/String");
    if (!strCls || ClearIfException(env)) return nullptr;

    jobjectArray arr = env->NewObjectArray((jsize)BAKED_ALLOWED_CERTS_COUNT, strCls, nullptr);
    if (!arr) return nullptr;

    for (jsize i = 0; i < (jsize)BAKED_ALLOWED_CERTS_COUNT; ++i) {
        jstring js = env->NewStringUTF(BAKED_ALLOWED_CERTS[i]); // already lowercase/no-colons
        env->SetObjectArrayElement(arr, i, js);
    }
    return arr;
}

// Convenience JNI predicate if you want a 1-call verdict from native.
extern "C" JNIEXPORT jboolean JNICALL
Java_com_corexero_nativelib_NativeLib_isSelfSignedWithTrustedKey(JNIEnv* env, jclass) {
    return (jboolean)(PackageOk(env) && SignerOk(env));
}
